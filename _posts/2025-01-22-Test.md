---
title: "Oceans: Theory to Implementation"
date: 2025-01-22 20:26:18 +0100
categories:
  - Graphics
  - Water Rendering
tags:
  - ocean
description: Introduction to Ocean Rendering
pin: true
math: true
---
## Introduction

We all know how beautiful water is and can be. I know I could stare at an ocean for hours just relaxing, watching the waves take shape slowly and then break down quickly while leaving behind nothing but foam and bubbles. Of course, because water is so cool and it has some very intriguing physical properties, our job as Graphics Programmers when it comes to Water Rendering can become quite difficult. Indeed, it does depend on how *deep* (pun intended :p) you are planning to go. In some cases you might be able to get away with just a flat plane and some scrolling textures, or a couple of sinusoidal waves acting upon the vertices of said plane. Well, in case you are wondering how AAA Games (and Movies too!) take on this challenge, look no further! I will be detailing how I implemented the famous Tessendorf Model for Ocean Rendering, in a PS5 Custom Engine Project for one of my 2nd Year University Assignments.

*Note: Sony, if you are reading this, first of all thank you :) and second of all, don't worry, I've made sure not to squeeze in any PS5 specific code*

## Tessendorf's Model
### High Level Overview

You might be asking yourself right about now something along the lines of "Who is Tessendorf and what did he Model?", which would be valid. To put it frankly, Jerry Tessendorf is basically the God of Ocean Simulation. In 2001 he released the Scientific Paper named "Simulating Ocean Water", where he discusses a method which was being used heavily in feature films at that time such as *Titanic (1997)*. Here are a couple of Movies that make use of Tessendorf's Model, or a similar approach: *Pirates of the Caribbean (2003-2017)*, *Moana (2016)*, *Life of Pi (2012)*. As for Games, here are a few: *Assassin's Creed IV: Black Flag (2013)*, *Sea of Thieves (2018)*, *ATLAS (2018)*. "Cool cool, but how does it actually work?" I hear you say?

Well here's a high-level overview. Tessendorf tells us that this method is based on statistical modelling of ocean waves with real life data, which in practice means that we use an Oceanographic Spectrum to generate displacement (and normals) for our plane. This spectrum represents a collection of sinusoidal functions that are defined in the **Frequency Domain** (Figure 1). After we evolve this Spectrum through time (to give the water the visual queue of movement) we can apply an **Inverse Fourier Transform** to convert back to the **Spatial Domain** (Figure 1). Finally, we can then calculate the Displacement and Slope (used for the Normals) maps. We can break this down into 4 "simple" steps:
1. Generate Ocean Spectrum
2. Advance Spectrum through time
3. Convert to Spatial Domain
4. Calculate Displacement and Slope maps

![Figure 1](../assets/images/ocean-blog-post/freq-vs-time-domain.png){: w="800" h="600" } _Figure 1: Sinusoidal functions represented in the time domain (top) and in the frequency domain (bottom)_ 

### Step 1 - Generate Ocean Spectrum

There are a lot of options to choose from when it comes to Oceanographic Spectra. I decided to use the JONSWAP Spectrum, which is based on the Phillips Spectrum (the same spectrum used by Tessendorf). The JONSWAP Spectrum has a few more parameters than the Phillips Spectrum and it can theoretically produce more accurate oceans. Speaking of parameters, let's see what this spectrum looks like in it's mathematical form and explain it's parameters:

$$

    S(f) = \alpha \frac{g^2}{(2\pi)^4 f^5} \exp\left(-\frac{5}{4} \left(\frac{f_p}{f}\right)^4\right) \gamma^{r(f)}

$$

  

Where:

- $f$: Wave frequency (Hz), also known as *omega*.

- $f_p$: Peak frequency (Hz), also known as *peak omega*, where the spectrum reaches its maximum.

- $g$: Acceleration due to gravity ($\approx 9.81$ $m/s^2$).

- $\alpha\ (\text{alpha})$: Dimensionless scaling factor (Phillips constant), which is related to the wave energy level.

- $\gamma\ (\text{gamma})$: Peak enhancement factor, typically ranging from 1 to 7, characterizing the sharpness of the spectrum peak.

- $r(f)$: Peak shape function, defined as:

  

$$

    r(f) = \exp\left(-\frac{(f - f_p)^2}{2 \sigma^2 f_p^2}\right)

$$

  Where:

- $\sigma\ (\text{sigma})$: Width parameter, which depends on the frequency:

  

$$

\sigma =

\begin{cases}

\sigma_a & \text{if } f \leq f_p \\

\sigma_b & \text{if } f > f_p

\end{cases}

$$

And:
- $\sigma_a$ = 0.07
- $\sigma_b$ = 0.09

In C++, it would look something like this:
```c++
struct JonswapParameters
{
    float gamma = 0.0f;
    
    float alpha = 0.0f;
    float peakOmega = 0.0f;
    // More to come later...
};
```

*A short note on Code Implementation: Since I wrote this using the PS5 api, I won't be sharing any api or shader specific code. Instead, I will be providing a mix between C++ and Pseudocode that should be enough to get you going in your desired api. I should also mention that my implementation is heavily based on Acerola's in Unity. He has some great videos on YouTube that I recommend you watch. Check the Bibliography for them!*

Speaking of code, we haven't discussed how we will approach all these steps. The best thing we can do is to write most of our computations in Compute Shaders. Doing this on the CPU would not be reliable in a Real-Time application. So how does one store these "spectrums", displacement maps and slope maps? Well, the answer is **Textures**. We want 16bit per channel float precision (i.e **RGBA16Float**) for more accurate computations. We also need it to be signed, as the data can very well be negative. As for the texture size, it should be powers of 2. I went with 512x512 for this simulation. Without further ado, I present you with the first compute shader of this voyage!

```hlsl
// Compute Initial Spectrum
// Adapted from: https://github.com/GarrettGunnell/Water

float DispersionRelation(float kMag) 
{
    return sqrt(G * kMag * tanh(min(kMag * computeParams->depth, 20)));
}

float DispersionDerivative(float kMag) 
{
    float th = tanh(min(kMag * computeParams->depth, 20));
    float ch = cosh(kMag * computeParams->depth);
    return G * (computeParams->depth * kMag / ch / ch + th) / DispersionRelation(kMag) / 2.0f;
}

float NormalizationFactor(float s) 
{
    float s2 = s * s;
    float s3 = s2 * s;
    float s4 = s3 * s;
    if (s < 5) return -0.000564f * s4 + 0.00776f * s3 - 0.044f * s2 + 0.192f * s + 0.163f;
    else return -4.80e-08f * s4 + 1.07e-05f * s3 - 9.53e-04f * s2 + 5.90e-02f * s + 3.93e-01f;
}

float Cosine2s(float theta, float s) 
{
	return NormalizationFactor(s) * pow(abs(cos(0.5f * theta)), 2.0f * s);
}

float SpreadPower(float omega, float peakOmega) 
{
	if (omega > peakOmega)
		return 9.77f * pow(abs(omega / peakOmega), -2.5f);
	else
		return 6.97f * pow(abs(omega / peakOmega), 5.0f);
}

float DirectionSpectrum(float theta, float omega) 
{
	float s = SpreadPower(omega, jonswapParams->peakOmega) + 16 * tanh(min(omega / jonswapParams->peakOmega, 20)) * jonswapParams->swell * jonswapParams->swell;
	
	return lerp(2.0f / 3.1415f * cos(theta) * cos(theta), Cosine2s(theta - jonswapParams->angle, s), jonswapParams->spreadBlend);
}

float TMACorrection(float omega) 
{
	float omegaH = omega * sqrt(computeParams->depth / G);
	if (omegaH <= 1.0f)
		return 0.5f * omegaH * omegaH;
	if (omegaH < 2.0f)
		return 1.0f - 0.5f * (2.0f - omegaH) * (2.0f - omegaH);
	
	return 1.0f;
}

float JONSWAP(float omega) 
{
	float sigma = (omega <= jonswapParams->peakOmega) ? 0.07f : 0.09f;
	
	float r = exp(-(omega - jonswapParams->peakOmega) * (omega - jonswapParams->peakOmega) / 2.0f / sigma / sigma / jonswapParams->peakOmega / jonswapParams->peakOmega);
	
	float oneOverOmega = 1.0f / (omega + 1e-6f);
	float peakOmegaOverOmega = jonswapParams->peakOmega / omega;
	return jonswapParams->scale * TMACorrection(omega) * jonswapParams->alpha * G * G
		* oneOverOmega * oneOverOmega * oneOverOmega * oneOverOmega * oneOverOmega
		* exp(-1.25f * peakOmegaOverOmega * peakOmegaOverOmega * peakOmegaOverOmega * peakOmegaOverOmega)
		* pow(abs(jonswapParams->gamma), r);
}

float ShortWavesFade(float kLength) 
{
	return exp(-jonswapParams->shortWavesFade * jonswapParams->shortWavesFade * kLength * kLength);
}

[numthreads(8, 8, 1)]
void main(uint2 threadID)
{
	float halfN = SPECTRUM_TEX_SIZE / 2.0f;
	
	float2 gauss1 = ;// Sample Gaussian Random numbers
	float2 gauss2 = ;// Sample Gaussian Random numbers
	
	float deltaK = 2.0f * PI / LENGTH_SCALE;
	float2 K = (threadID.xy - halfN) * deltaK;
	float kLength = length(K);
	
	float kAngle = atan2(K.y, K.x);
	float omega = DispersionRelation(kLength);
	float dOmegadk = DispersionDerivative(kLength);
	
	float spectrum = JONSWAP(omega) * DirectionSpectrum(kAngle, omega) * ShortWavesFade(kLength);
	
	initial_spectrum[threadID.xy] = float4(float2(gauss2.x, gauss1.y) * float2(sqrt(2 * spectrum * abs(dOmegadk) / kLength * deltaK * deltaK)), 0.0f, 0.0f);
}
```

This needs some unpacking to do, so let's break it down:
- `deltaK` is used to discretize the frequency domain
- `K` represents the number of waves vector for that sample
- `kLength` is used later on in the Dispersion Relation calculation
- `DispersionRelation() & DispersionDerivative()` calculates the dispersion relation, as defined by Tessendorf. This is crucial for Energy conservation. It also tells us how the ocean acts at different depths and wave lengths
- `JONSWAP()` calculates the initial spectrum
- `DirectionSpectrum()` calculates a value which is used to influence the waves in a user-defined wind direction 
- `ShortWavesFade()` is used to influence the amount of short waves present in the simulation. a low value will lead to very detailed and rough oceans, whereas a high value will result in smoother and leaner oceans

Let us revisit the `JonswapParameters` struct after we've gained all this information:
```c++
struct JonswapParameters
{
    float scale = 0.0f; // Used to scale the Spectrum [1.0f, 5.0f] --> Value Range
    float spreadBlend = 0.0f; // Used to blend between agitated water motion, and windDirection [0.0f, 1.0f]
    float swell = 0.0f; // Influences wave choppines, the bigger the swell, the longer the wave length [0.0f, 1.0f]
    float gamma = 0.0f; // Defines the Spectrum Peak [0.0f, 7.0f]
    float shortWavesFade = 0.0f; // [0.0f, 1.0f]

    float windDirection = 0.0f; // [0.0f, 360.0f]
    float fetch = 0.0f; // Distance over which Wind impacts Wave Formation [0.0f, 10000.0f]
    float windSpeed = 0.0f; // [0.0f, 100.0f]
    
    float angle = 0.0f;
    float alpha = 0.0f;
    float peakOmega = 0.0f;
};
```

Great! Now, we can dispatch a compute shader like so:
```c++
uint32_t tgx = (TEXTURE_SIZE + 7) / 8;
uint32_t tgy = (TEXTURE_SIZE + 7) / 8;
if (ShouldComputeSpectrum)
{
	// Initial Spectrum can be safely calculated only once per parameter change 
    ShouldComputeSpectrum = false;

    // Initial Spectrum Compute
    setShader(m_computeInitialSpectrum);
    setRwTextures(0, 1, &m_spectrumTexture);

    dispatch(tgx, tgy, 1);

    // Sync
    ...

}
```

You can visualize this texture on your plane mesh, or in your Graphics Debugger. Regardless, it should look something like this:
![Figure 1](../assets/images/ocean-blog-post/initial-spectrum.png){: w="800" h="600" } _Figure 2: Initial JONSWAP Spectrum_
### Step 2 - Advance Spectrum

### Step 3 - Convert to Spatial Domain

### Step 4 - Calculate Displacement and Slope Maps


## Tweaks and Fixes


## Future Work


## Bibliography

Figure 1: https://neurotext.library.stonybrook.edu/C7/C7_1/C7_1.html